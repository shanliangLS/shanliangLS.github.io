<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Nginx 高并发配置 | 钐椋的博客</title><script src="https://cdn.bootcss.com/valine/1.4.4/Valine.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.2.0"></head><body><header><nav><a href="/">首页</a><a href="/archives/">归档</a></nav></header><main><article><div id="post-bg"><div id="post-title"><div id="post-info"><span>date:<time datetime="2023-02-03T02:50:00.000Z" id="date"> 2023-02-03</time></span><br><span>updated:<time datetime="2023-02-03T03:00:04.381Z" id="updated"> 2023-02-03</time></span></div><h1>Nginx 高并发配置</h1><hr></div><div id="post-content"><p>参考 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f0f05c02e93a">Nginx 高并发下报错 connect() failed (110: Connection timed out) while connecting to upstream</a></p>
<p>背景<br>在对应用服务进行压力测试时，Nginx在持续压测请求1min左右后开始报错，花了一些时间对报错的原因进行排查，并最终定位到问题，现将过程总结下。</p>
<p>压测工具<br>这里压测使用的是siege, 其非常容易指定并发访问数以及并发时间，以及有非常清晰的结果反馈，成功访问数，失败数，吞吐率等性能结果。</p>
<p>压测指标<br>单接口压测，并发100，持续1min。</p>
<p>压测工具 报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">The server is now under siege...<br>[error] socket: unable to connect sock.c:249: Connection timed out<br>[error] socket: unable to connect sock.c:249: Connection timed out<br></code></pre></td></tr></table></figure>

<p>Nginx error.log 报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">2018/11/21 17:31:23 [error] 15622<span class="hljs-comment">#0: *24993920 connect() failed (110: Connection timed out) while connecting to upstream, client: 192.168.xx.xx, server: xx-qa.xx.com, request: &quot;GET /guide/v1/activities/1107 HTTP/1.1&quot;, upstream: &quot;http://192.168.xx.xx:8082/xx/v1/activities/1107&quot;, host: &quot;192.168.86.90&quot;</span><br>2018/11/21 18:21:09 [error] 4469<span class="hljs-comment">#0: *25079420 connect() failed (110: Connection timed out) while connecting to upstream, client: 192.168.xx.xx, server: xx-qa.xx.com, request: &quot;GET /guide/v1/activities/1107 HTTP/1.1&quot;, upstream: &quot;http://192.168.xx.xx:8082/xx/v1/activities/1107&quot;, host: &quot;192.168.86.90&quot;</span><br></code></pre></td></tr></table></figure>

<p>排查问题</p>
<p>看到 timed out 第一感觉是，应用服务存在性能问题，导致并发请求时无法响应请求；通过排查应用服务的日志，发现其实应用服务并没有任何报错；</p>
<p>观察应用服务的CPU负载(Docker 容器 docker state id) ，发现其在并发请求时CPU使用率升高，再无其他异常，属于正常情况。不过持续观察发现，在压测报错开始后，应用服务所在的CPU负载降低，应用服务日志里也没有了请求日志，暂时可以判定无法响应请求应该来自应用服务链路的前一节点，也就是Nginx；</p>
<p>通过命令排查Nginx所在服务器，压测时的TCP连接情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看当前80端口的连接数</span><br>netstat -nat|grep -i <span class="hljs-string">&quot;80&quot;</span>|wc -l<br>5407<br><br><span class="hljs-comment"># 查看当前TCP连接的状态</span><br>netstat -na | awk <span class="hljs-string">&#x27;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#x27;</span><br>LISTEN 12<br>SYN_RECV 1<br>ESTABLISHED 454<br>FIN_WAIT1 1<br>TIME_WAIT 5000<br></code></pre></td></tr></table></figure>

<p>发现在TCP的连接有两个异常点</p>
<p>竟然有5k多个连接<br>TCP状态TIME_WAIT 到5000个后停止增长<br>关于这两点开始进行分析：</p>
<p>理论上100个并发用户数压测，应该只有100个连接才对，造成这个原因应该是 siege 压测时创建了5000个连接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看siege配置</span><br>vim ~/.siege/siege.conf<br><br><span class="hljs-comment"># 真相大白，原来siege在压测时，连接默认是close，也就是说在持续压测时，每个请求结束后，直接关闭连接，然后再创建新的连接，那么就可以理解为什么压测时Nginx所在服务器TCP连接数5000多，而不是100；</span><br><br><span class="hljs-comment"># Connection directive. Options &quot;close&quot; and &quot;keep-alive&quot; Starting with</span><br><span class="hljs-comment"># version 2.57, siege implements persistent connections in accordance </span><br><span class="hljs-comment"># to RFC 2068 using both chunked encoding and content-length directives</span><br><span class="hljs-comment"># to determine the page size. </span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># To run siege with persistent connections set this to keep-alive. </span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># CAUTION:        Use the keep-alive directive with care.</span><br><span class="hljs-comment"># DOUBLE CAUTION: This directive does not work well on HPUX</span><br><span class="hljs-comment"># TRIPLE CAUTION: We don&#x27;t recommend you set this to keep-alive</span><br><span class="hljs-comment"># ex: connection = close</span><br><span class="hljs-comment">#     connection = keep-alive</span><br><span class="hljs-comment">#</span><br>connection = close<br></code></pre></td></tr></table></figure>

<p>TIME_WAIT 到5000分析，这要先弄清楚，TCP状态TIME_WAIT是什么含义</p>
<p>TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认；TCP要保证在所有可能的情况下使得所有的数据都能够被正确送达。当你关闭一个socket时，主动关闭一端的socket将进入TIME_WAIT状态，而被动关闭一方则转入CLOSED状态，这的确能够保证所有的数据都被传输。</p>
<p>从TIME-WAIT定义中分析得知，当压测工具关闭连接后，实际上Nginx所在机器连接并未立刻CLOSED，而是进入TIME-WAIT状态，网上可以搜到非常多讲解TIME-WAIT过多导致丢包的情况，与我在压测时所遇到情况一样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看Nginx所在服务器的配置</span><br>cat /etc/sysctl.conf <br><span class="hljs-comment"># sysctl settings are defined through files in</span><br><span class="hljs-comment"># /usr/lib/sysctl.d/, /run/sysctl.d/, and /etc/sysctl.d/.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Vendors settings live in /usr/lib/sysctl.d/.</span><br><span class="hljs-comment"># To override a whole file, create a new file with the same in</span><br><span class="hljs-comment"># /etc/sysctl.d/ and put new settings there. To override</span><br><span class="hljs-comment"># only specific settings, add a file with a lexically later</span><br><span class="hljs-comment"># name in /etc/sysctl.d/ and put new settings there.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For more information, see sysctl.conf(5) and sysctl.d(5).</span><br>net.ipv6.conf.all.disable_ipv6 = 1<br>net.ipv6.conf.default.disable_ipv6 = 1<br>net.ipv6.conf.lo.disable_ipv6 = 1<br><br>vm.swappiness = 0<br>net.ipv4.neigh.default.gc_stale_time=120<br><br><br><span class="hljs-comment"># see details in https://help.aliyun.com/knowledge_detail/39428.html</span><br>net.ipv4.conf.all.rp_filter=0<br>net.ipv4.conf.default.rp_filter=0<br>net.ipv4.conf.default.arp_announce = 2<br>net.ipv4.conf.lo.arp_announce=2<br>net.ipv4.conf.all.arp_announce=2<br><br><br><span class="hljs-comment"># see details in https://help.aliyun.com/knowledge_detail/41334.html</span><br>net.ipv4.tcp_max_tw_buckets = 5000<br>net.ipv4.tcp_syncookies = 1<br>net.ipv4.tcp_max_syn_backlog = 1024<br>net.ipv4.tcp_synack_retries = 2<br>kernel.sysrq = 1<br>fs.file-max = 65535<br>net.ipv4.ip_forward = 1<br>net.ipv4.tcp_fin_timeout = 30<br>net.ipv4.tcp_max_syn_backlog = 10240<br>net.ipv4.tcp_keepalive_time = 1200<br>net.ipv4.tcp_synack_retries = 3<br>net.ipv4.tcp_syn_retries = 3<br>net.ipv4.tcp_max_orphans = 8192<br>net.ipv4.tcp_max_tw_buckets = 5000<br>net.ipv4.tcp_window_scaling = 0<br>net.ipv4.tcp_sack = 0<br>net.ipv4.tcp_timestamps = 0<br>net.ipv4.tcp_syncookies = 1<br>net.ipv4.tcp_tw_reuse = 1<br>net.ipv4.tcp_tw_recycle = 1<br>net.ipv4.ip_local_port_range = 1024 65000<br>net.ipv4.icmp_echo_ignore_all = 0<br></code></pre></td></tr></table></figure>

<p>net.ipv4.tcp_max_tw_buckets = 50005000表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。</p>
<p>优化方案<br>参照在网上搜索获取的信息，调整Linux内核参数优化：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；<br>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；<br>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。<br>net.ipv4.tcp_fin_timeout = 30 表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。<br>net.ipv4.tcp_keepalive_time = 1200 表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。<br>net.ipv4.ip_local_port_range = 1024 65000 表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。<br>net.ipv4.tcp_max_syn_backlog = 8192 表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。<br>net.ipv4.tcp_max_tw_buckets = 5000表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。默认为180000，改为5000。<br></code></pre></td></tr></table></figure><div id="paginator"></div></div><div id="post-footer"><hr><a href="/2023/12/28/Linux-%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/">← Prev Linux 查找文件</a><span style="color: #fe2"> | </span><a href="/2022/10/28/Centos7-%E5%AE%89%E8%A3%85-Python3.8/">Centos7 安装 Python3.8 Next →</a><hr></div><div id="bottom-btn"><a id="to-top" href="#post-title" title="to top">∧</a></div><details id="reward"><summary>打赏</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div><script>new Valine({
 el: '#Valine'
 , appId: ''
 , appKey: ''
 , placeholder: '此条评论委托企鹅物流发送'
})</script></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/shanliangLS"> Dr.Shining</a></h1><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">34</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">22</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">7</span></div></section></div><div id="aside-block"></div><footer><nobr><span class="text-title">©</span><span class="text-content">github.com/shanliangLS</span></nobr><wbr><wbr><nobr>published with&nbsp;<a target="_blank" rel="noopener" href="http://hexo.io">Hexo&nbsp;</a></nobr><wbr><nobr>Theme&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight&nbsp;</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/arknights.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script></body></html>