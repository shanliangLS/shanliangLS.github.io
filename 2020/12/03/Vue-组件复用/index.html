<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Vue 组件复用 | 钐椋的博客</title><script src="https://cdn.bootcss.com/valine/1.4.4/Valine.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.2.0"></head><body><header><nav><a href="/">首页</a><a href="/archives/">归档</a></nav></header><main><article><div id="post-bg"><div id="post-title"><div id="post-info"><span>date:<time datetime="2020-12-03T06:47:27.000Z" id="date"> 2020-12-03</time></span><br><span>updated:<time datetime="2021-05-14T05:34:27.569Z" id="updated"> 2021-05-14</time></span></div><h1>Vue 组件复用</h1><hr></div><div id="post-content"><p>组件，是一个具有一定功能，且不同组件间功能相对独立的模块。组件可以是一个按钮、一个输入框、一个视频播放器等等。</p>
<p>可复用组件，高内聚、低耦合。</p>
<p>那么，什么构成了组件呢。以浏览器的原生组件 video 为例，分析一下组件的组成部分。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span></span><br><span class="hljs-tag"> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;example.mp4&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;320&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;240&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;loadHandler&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;errorHandler&quot;</span>&gt;</span><br> Your browser does not support the video tag.<br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>实例中能看出，组件由状态、事件和嵌套的片断组成。状态，是组件当前的某些数据或属性，如 video 中的 src、width 和 height。事件，是组件在特定时机触发一些操作的行为，如 video 在视频资源加载成果或失败时会触发对应的事件来执行处理。片段，指的是嵌套在组件标签中的内容，该内容会在某些条件下展现出来，如在浏览器不支持 video 标签时显示提示信息。</p>
<p>在 Vue 组件中，状态称为 props，事件称为 events，片段称为 slots。组件的构成部分也可以理解为组件对外的接口。良好的可复用组件应当定义一个清晰的公开接口。</p>
<ul>
<li>Props 允许外部环境传递数据给组件</li>
<li>Events 允许组件触发外部环境的副作用</li>
<li>Slots 允许外部环境将额外的内容组合在组件中。</li>
</ul>
<p>使用 vue 对 video 组件做拓展，构造出一个支持播放列表的组件 myVideo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;my-video<br> :playlist&#x3D;&quot;playlist&quot;<br> width&#x3D;&quot;320&quot;<br> height&#x3D;&quot;240&quot;<br> @load&#x3D;&quot;loadHandler&quot;<br> @error&#x3D;&quot;errorHandler&quot;<br> @playnext&#x3D;&quot;nextHandler&quot;<br> @playprev&#x3D;&quot;prevHandler&quot;&gt;<br> &lt;div slot&#x3D;&quot;endpage&quot;&gt;&lt;&#x2F;div&gt;<br>&lt;&#x2F;my-video&gt;<br></code></pre></td></tr></table></figure>

<p>myVideo 组件有着清晰的接口，接收播放列表、播放器宽高等状态，能够触发加载成功或失败、播放上一个或下一个的事件，并且能自定义播放结束时的尾页，可用于插入广告或显示下一个视频信息。</p>
<h2 id="构造思想"><a href="#构造思想" class="headerlink" title="构造思想"></a>构造思想</h2><p><em>引用自 <a target="_blank" rel="noopener" href="https://www.jb51.net/article/109347.htm">https://www.jb51.net/article/109347.htm</a></em></p>
<h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h3><p>在 Vue.js 中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。</p>
<h3 id="命名业务无关"><a href="#命名业务无关" class="headerlink" title="命名业务无关"></a>命名业务无关</h3><p>组件的命名应该跟业务无关。应该依据组件的功能为组件命名。</p>
<p>例如，一个展示公司部门的列表，把每一项作为一个组件，并命名为 DepartmentItem。这时，有一个需求要展示团队人员列表，样式跟刚刚的部门列表一样。显然，DepartmentItem 这个名字就不适合了。</p>
<p>因此，可复用组件在命名上应避免跟业务扯上关系，以组件的角色、功能对其命名。Item、ListItem、Cell。可以参考 Bootstrap、ElementUI 等一些 UI 框架的命名。</p>
<h3 id="业务数据无关"><a href="#业务数据无关" class="headerlink" title="业务数据无关"></a>业务数据无关</h3><p>可复用组件只负责 UI 上的展示和一些交互以及动画，如何获取数据跟它无关，因此不要在组件内部去获取数据，以及任何与服务端打交道的操作。可复用组件只实现 UI 相关的功能。</p>
<h3 id="组件职责"><a href="#组件职责" class="headerlink" title="组件职责"></a>组件职责</h3><p>约束好组件的职责，能让组件更好地解耦，知道什么功能是组件实现的，什么功能不需要实现。</p>
<p>组件可以分为通用组件（可复用组件）和业务组件（一次性组件）。</p>
<p>可复用组件实现通用的功能（不会因组件使用的位置、场景而变化）：</p>
<ul>
<li>UI 的展示</li>
<li>与用户的交互（事件）</li>
<li>动画效果</li>
</ul>
<p>业务组件实现偏业务化的功能：</p>
<ul>
<li>获取数据</li>
<li>和 vuex 相关的操作</li>
<li>埋点</li>
<li>引用可复用组件</li>
</ul>
<p>可复用组件应尽量减少对外部条件的依赖，所有与 vuex 相关的操作都不应在可复用组件中出现。</p>
<p>组件应当避免对其父组件的依赖，不要通过 this.$parent 来操作父组件的示例。父组件也不要通过 this.$children 来引用子组件的示例，而是通过子组件的接口与之交互。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>可复用组件除了定义一个清晰的公开接口外，还需要有命名空间。命名空间可以避免与浏览器保留标签和其他组件的冲突。特别是当项目引用外部 UI 组件或组件迁移到其他项目时，命名空间可以避免很多命名冲突的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;xl-button&gt;&lt;&#x2F;xl-button&gt;<br>&lt;xl-table&gt;&lt;&#x2F;xl-table&gt;<br>&lt;xl-dialog&gt;&lt;&#x2F;xl-dialog&gt;<br>...<br></code></pre></td></tr></table></figure>

<p>业务组件也可以有命令空间，跟通用组件区分开。这里用 st (section) 来代表业务组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;st-recommend&gt;&lt;&#x2F;st-recommend&gt;<br>&lt;st-qq-movie&gt;&lt;&#x2F;st-qq-movie&gt;<br>&lt;st-sohu-series&gt;&lt;&#x2F;st-sohu-series&gt;<br></code></pre></td></tr></table></figure>

<h3 id="上下文无关"><a href="#上下文无关" class="headerlink" title="上下文无关"></a>上下文无关</h3><p>还是上面那句话，可复用组件应尽量减少对外部条件的依赖。没有特别需求且单个组件不至于过重的的前提下，不要把一个有独立功能的组件拆分成若干个小组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;table-wrapper&gt;   <br> &lt;table-header slot&#x3D;&quot;header&quot; :headers&#x3D;&quot;exampleHeader&quot;&gt;&lt;&#x2F;table-header&gt;   <br> &lt;table-body slot&#x3D;&quot;body&quot; :body-content&#x3D;&quot;exampleContents&quot;&gt;&lt;&#x2F;table-body&gt;   <br>&lt;&#x2F;table-wrapper&gt;<br></code></pre></td></tr></table></figure>

<p>TableHeader 组件和 TableBody 组件依赖当前的上下文，即 TableWrapper 组件嵌套的环境下。你可以有更好的解决办法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;xl-table :headers&#x3D;&quot;exampleHeader&quot; :body-content&#x3D;&quot;exampleContents&quot;&gt;&lt;&#x2F;xl-table&gt;<br></code></pre></td></tr></table></figure>

<p>上下文无关原则能够降低组件使用的门槛。</p>
<h3 id="数据扁平化"><a href="#数据扁平化" class="headerlink" title="数据扁平化"></a>数据扁平化</h3><p>定义组件接口时，尽量不要将整个对象作为一个 prop 传进来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 反例 --&gt;<br>&lt;card :item&#x3D;&quot;&#123; title: item.name, description: item.desc, poster: item.img &#125;&gt;&lt;&#x2F;card&gt;<br></code></pre></td></tr></table></figure>

<p>每个 prop 应该是一个简单类型的数据。这样做有下列几点好处：</p>
<ul>
<li>组件接口清晰</li>
<li>props 校验方便</li>
</ul>
<p>当服务端返回的对象中的 key 名称与组件接口不一样时，不需要重新构造一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;card<br> :title&#x3D;&quot;item.name&quot;<br> :description&#x3D;&quot;item.desc&quot;<br> :poster&#x3D;&quot;item.img&quot;&gt;<br>&lt;&#x2F;card&gt;<br></code></pre></td></tr></table></figure>

<p>扁平化的 props 能让我们更直观地理解组件的接口。</p>
<h3 id="使用自定义事件实现数据的双向绑定"><a href="#使用自定义事件实现数据的双向绑定" class="headerlink" title="使用自定义事件实现数据的双向绑定"></a>使用自定义事件实现数据的双向绑定</h3><p>有时候，对于一个状态，需要同时从组件内部和组件外部去改变它。</p>
<p>例如，模态框的显示和隐藏，父组件可以初始化模态框的显示，模态框组件内部的关闭按钮可以让其隐藏。一个好的办法是，使用自定义事件改变父组件中的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;modal :show&#x3D;&quot;show&quot; @showchange&#x3D;&quot;show &#x3D; argument[0]&quot;&gt;&lt;&#x2F;modal&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- Modal.vue --&gt;<br> <br>&lt;template&gt;<br> &lt;div v-show&#x3D;&quot;show&quot;&gt;<br>  &lt;h3&gt;标题&lt;&#x2F;h3&gt;<br>  &lt;p&gt;内容&lt;&#x2F;p&gt;<br>  &lt;a href&#x3D;&quot;javascript:;&quot; rel&#x3D;&quot;external nofollow&quot; rel&#x3D;&quot;external nofollow&quot; @click&#x3D;&quot;close&quot;&gt;关闭&lt;&#x2F;a&gt;<br> &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br> <br>&lt;script&gt;<br> export default &#123;<br>  props: &#123;<br>   show: String<br>  &#125;,<br>  methods: &#123;<br>   close () &#123;<br>    this.$emit(&#39;input&#39;, false)<br>   &#125;<br>  &#125;<br> &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>

<p>用户点击关闭按钮时，Modal 组件发送一个 input 自定义事件给父组件。父组件监听到 input 事件时，把 show 设置为事件回调的第一个参数。</p>
<p>特别地，当状态名称为 value，事件名称为 input 时，可以使用 v-model 指令语法糖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;modal :value&#x3D;&quot;show&quot; @input&#x3D;&quot;show &#x3D; argument[0]&quot;&gt;&lt;&#x2F;modal&gt;<br></code></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;modal v-model&#x3D;&quot;show&quot;&gt;&lt;&#x2F;model&gt;<br></code></pre></td></tr></table></figure>

<p>要让组件的 v-model 生效，它必须：</p>
<ul>
<li>接受一个 value 属性</li>
<li>在有新的 value 时触发 input 事件</li>
</ul>
<p>注意：由于每个组件的 input 事件只能用来对一个数据进行双向绑定，所以当存在多个需要向上同步的数据时，请不要使用 v-model，请使用多个自定义事件，并在父组件中同步新的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;modal<br> :show&#x3D;&quot;show&quot; @showchange&#x3D;&quot;show &#x3D; argument[0]&quot;<br> :content&#x3D;&quot;content&quot; @contentchange&#x3D;&quot;content &#x3D; argument[0]&quot;&gt;<br>&lt;&#x2F;model&gt;<br></code></pre></td></tr></table></figure>

<h3 id="使用自定义-watcher-优化-DOM-操作"><a href="#使用自定义-watcher-优化-DOM-操作" class="headerlink" title="使用自定义 watcher 优化 DOM 操作"></a>使用自定义 watcher 优化 DOM 操作</h3><p>在开发中，有些逻辑无法使用数据绑定，无法避免需要对 DOM 的操作。例如，视频的播放需要同步 Video 对象的播放操作及组件内的播放状态。可以使用自定义 watcher 来优化 DOM 的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- MyVideo.vue --&gt;<br> <br>&lt;template&gt;<br> &lt;div&gt;<br>  &lt;video ref&#x3D;&quot;video&quot; src&#x3D;&quot;src&quot;&gt;&lt;&#x2F;video&gt;<br>  &lt;a href&#x3D;&quot;javascript:;&quot; rel&#x3D;&quot;external nofollow&quot; rel&#x3D;&quot;external nofollow&quot; @click&#x3D;&quot;togglePlay&quot;&gt;&#123;&#123; playing ? &#39;暂停&#39; : &#39;播放&#39; &#125;&#125;&lt;&#x2F;a&gt;<br> &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br> <br>&lt;script&gt;<br> export default &#123;<br>  props: &#123;<br>   src: String &#x2F;&#x2F; 播放地址<br>  &#125;,<br>  data () &#123;<br>   return &#123;<br>    playing: false &#x2F;&#x2F; 是否正在播放<br>   &#125;<br>  &#125;,<br>  watch: &#123;<br>   &#x2F;&#x2F; 播放状态变化时，执行对应操作<br>   playing (val) &#123;<br>    let video &#x3D; this.$refs.video<br>    if (val) &#123;<br>     video.play();<br>    &#125; else &#123;<br>     video.pause();<br>    &#125;<br>   &#125;<br>  &#125;,<br>  method: &#123;<br>   &#x2F;&#x2F; 切换播放状态<br>   togglePlay () &#123;<br>    this.playing &#x3D; !this.playing<br>   &#125;<br>  &#125;<br> &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>

<p>示例中，自定义 watcher 在监听到 playing 状态变化时，会执行播放或暂停操作。遇到对视频播放状态的处理时，只需要关注 playing 状态即可。</p>
<h3 id="项目骨架"><a href="#项目骨架" class="headerlink" title="项目骨架"></a>项目骨架</h3><p>单组件不异过重，组件在功能独立的前提下应该尽量简单，越简单的组件可复用性越强。当你实现组件的代码，不包括CSS，有好几百行了（这个大小视业务而定），那么就要考虑拆分成更小的组件。</p>
<p>当组件足够简单时，就可以在一个更大的业务组件中去自由组合这些组件，实现我们的业务功能。因此，理想情况下，组件的引用层级，只有两级。业务组件引用通用组件。</p>
<p>我们可以得到一个扁平化的结构。</p>
<p><img src="https://img.jbzj.com/file_images/article/201703/2017032409221725.jpg" alt="img"></p>
<p>在一个庞大的项目当中，组件间的引用关系会更复杂一些。当单页应用有多个路由，每个路由组件过重，需要拆分模块时。组件结构会变成下图这样。</p>
<p><img src="https://img.jbzj.com/file_images/article/201703/2017032409221826.jpg" alt="img"></p>
<p>按照这个思路构建我们的项目，最后的源代码目录结构（不包括构建流程文件）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">│ App.vue     # 顶级组件<br>│ client-entry.js # 前端入口文件<br>│ config.js    # 配置文件<br>│ main.js     # 主入口文件<br>│ <br>├─api        # 接口 API<br>├─assets      # 静态资源<br>├─components    # 通用组件<br>├─directives    # 自定义指令<br>├─mock       # Mock 数据<br>├─plugins      # 自定义插件<br>├─router      # 路由配置<br>├─sections     # 业务组件<br>├─store       # Vuex Store<br>├─utils       # 工具模块<br>└─views       # 路由页面组件<br></code></pre></td></tr></table></figure>

<p>在通用组件中还可以区分容器组件、布局组件和其他功能性组件等。</p>
<h2 id="Vue-组件封装打包，发布到-npm"><a href="#Vue-组件封装打包，发布到-npm" class="headerlink" title="Vue 组件封装打包，发布到 npm"></a>Vue 组件封装打包，发布到 npm</h2><p><em>引用自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31851435/article/details/106647833">https://blog.csdn.net/qq_31851435/article/details/106647833</a></em></p>
<h3 id="使用-webpack-simple-模板"><a href="#使用-webpack-simple-模板" class="headerlink" title="使用 webpack-simple 模板"></a>使用 webpack-simple 模板</h3><h4 id="1-新建一个-vue-项目"><a href="#1-新建一个-vue-项目" class="headerlink" title="1. 新建一个 vue 项目"></a>1. 新建一个 vue 项目</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vue init webpack-simple 项目名<br></code></pre></td></tr></table></figure>

<p>然后再 <code>npm install</code> 安装一下依赖，<code>npm run dev</code> 测试</p>
<h4 id="2-在新建项目的-src-目录下新建一个目录（components）用来存放所有自定义组件源码"><a href="#2-在新建项目的-src-目录下新建一个目录（components）用来存放所有自定义组件源码" class="headerlink" title="2. 在新建项目的 src 目录下新建一个目录（components）用来存放所有自定义组件源码"></a>2. 在新建项目的 src 目录下新建一个目录（components）用来存放所有自定义组件源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">src&#x2F;components&#x2F;xx-btn&#x2F;xx-btn.vue<br></code></pre></td></tr></table></figure>

<h4 id="3-组件封装好后在组件目录（components）下新建一个-index-js-文件，为组件库的入口文件"><a href="#3-组件封装好后在组件目录（components）下新建一个-index-js-文件，为组件库的入口文件" class="headerlink" title="3. 组件封装好后在组件目录（components）下新建一个 index.js 文件，为组件库的入口文件"></a>3. 组件封装好后在组件目录（components）下新建一个 index.js 文件，为组件库的入口文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">src&#x2F;components&#x2F;index.js<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入封装的组件</span><br><span class="hljs-keyword">import</span> xxBtn <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./xx-btn/xx-btn.vue&#x27;</span><br> <br><span class="hljs-keyword">const</span> components = &#123;<br>  <span class="hljs-comment">// 通过install来安装组件</span><br>  <span class="hljs-function"><span class="hljs-title">install</span>(<span class="hljs-params">Vue</span>)</span> &#123;<br>    Vue.component(<br>      <span class="hljs-string">&#x27;xxBtn&#x27;</span>, xxBtn<br>    )<br>  &#125;<br>&#125;<br> <br><span class="hljs-comment">// 注意这里的判断，很重要</span><br><span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params"><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-built_in">window</span>.Vue</span>)</span> &#123;<br>  <span class="hljs-built_in">window</span>.Vue.use(comment)<br>&#125;<br> <br><span class="hljs-comment">// 导出组件库</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> components<br></code></pre></td></tr></table></figure>

<h4 id="4-修改-package-json-文件"><a href="#4-修改-package-json-文件" class="headerlink" title="4. 修改 package.json 文件"></a>4. 修改 package.json 文件</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs json"> &#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;xx-btn&quot;</span>, <span class="hljs-comment">// 发布的模块名称，发布线上后，可以通过npm install xx-btn来引用该模块，一般Vue组件以vue-开头</span><br>  <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;test npm&quot;</span>, <span class="hljs-comment">// 组件库描述</span><br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>, <span class="hljs-comment">// 版本号</span><br>  <span class="hljs-attr">&quot;author&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-comment">// 作者</span><br>  <span class="hljs-attr">&quot;license&quot;</span>: <span class="hljs-string">&quot;MIT&quot;</span>, <span class="hljs-comment">// 代码授权许可</span><br>  <span class="hljs-attr">&quot;private&quot;</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 公开项目，因为组件包是公用的，所以private要改为false</span><br>  <br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123; <span class="hljs-comment">// 运行命令</span><br>    <span class="hljs-attr">&quot;dev&quot;</span>: <span class="hljs-string">&quot;cross-env NODE_ENV=development webpack-dev-server --open --hot&quot;</span>,<br>    <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;cross-env NODE_ENV=production webpack --progress --hide-modules&quot;</span><br>  &#125;,<br>  <br>  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;dist/xx-btn.min.js&quot;</span>, <span class="hljs-comment">// 打包后的入口文件，若不配置，则在其他项目中就无法使用import xx from &#x27;包名&#x27;来引入组件，只能以包名作为起点来指定相对路径</span><br>  <br>  <span class="hljs-attr">&quot;keywords&quot;</span>: [ <span class="hljs-comment">// 关键词，可以通过npm搜索你填写的关键词找到你的模块</span><br>    <span class="hljs-string">&quot;xx-btn&quot;</span>,<br>    <span class="hljs-string">&quot;components&quot;</span><br>  ],<br>  <br>  <span class="hljs-attr">&quot;files&quot;</span>: [ <span class="hljs-comment">// 指定打包后发布到npm的文件，没指定则不传，package.json是默认上传的</span><br>    <span class="hljs-string">&quot;dist&quot;</span>,<br>    <span class="hljs-string">&quot;src/components&quot;</span><br>  ],<br> <br>  <span class="hljs-attr">&quot;homepage&quot;</span>: <span class="hljs-string">&quot;https://xx.github.io/xx/xx-btn/dist/index.html&quot;</span>, <span class="hljs-comment">// 项目官网的url</span><br>  <br>  <span class="hljs-attr">&quot;bugs&quot;</span>: &#123; <span class="hljs-comment">// 填写一个bug提交地址或者一个邮箱，被你的模块坑到的人可以通过这里吐槽</span><br>    <span class="hljs-attr">&quot;url&quot;</span>: <span class="hljs-string">&quot;https://github.com/xx/xx-btn/issues&quot;</span><br>  &#125;,<br>  <br>  <span class="hljs-attr">&quot;repository&quot;</span>: &#123; <span class="hljs-comment">// 指定代码所在的仓库地址</span><br>    <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;git&quot;</span>,<br>    <span class="hljs-attr">&quot;url&quot;</span>: <span class="hljs-string">&quot;https://github.com/xx/xx-btn.git&quot;</span><br>  &#125;,<br>  <br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-修改-webpack-config-js-文件"><a href="#5-修改-webpack-config-js-文件" class="headerlink" title="5. 修改 webpack.config.js 文件"></a>5. 修改 webpack.config.js 文件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// entry: &quot;./src/main.js&quot;,</span><br>entry: <span class="hljs-string">&quot;./src/components/index.js&quot;</span>, <span class="hljs-comment">// 入口文件</span><br> <br>output: &#123; <span class="hljs-comment">// 修改输出文件到 dist 下</span><br> <br>  path: path.resolve(__dirname, <span class="hljs-string">&#x27;./dist&#x27;</span>),<br>  publicPath: <span class="hljs-string">&#x27;/dist/&#x27;</span>,<br>  <br>  <span class="hljs-comment">// filename: &#x27;build.js&#x27;</span><br>  filename: <span class="hljs-string">&quot;xx-btn.min.js&quot;</span>, <span class="hljs-comment">// 生成的文件名</span><br>  library: <span class="hljs-string">&quot;xx-btn&quot;</span>, <span class="hljs-comment">// 指定的就是你使用require时的模块名</span><br>  libraryTarget: <span class="hljs-string">&quot;umd&quot;</span>, <span class="hljs-comment">// 会生成不同umd的代码,可以只是commonjs标准的，也可以是指amd标准的，也可以只是通过script标签引入的</span><br>  umdNamedDefine: <span class="hljs-literal">true</span> <span class="hljs-comment">// 会对 UMD 的构建过程中的 AMD 模块进行命名。否则就使用匿名的 define</span><br>&#125;,<br></code></pre></td></tr></table></figure>

<h4 id="6-编译打包，生成的文件在-dist-目录下"><a href="#6-编译打包，生成的文件在-dist-目录下" class="headerlink" title="6. 编译打包，生成的文件在 dist 目录下"></a>6. 编译打包，生成的文件在 dist 目录下</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run build<br></code></pre></td></tr></table></figure>

<h4 id="7-测试插件"><a href="#7-测试插件" class="headerlink" title="7. 测试插件"></a>7. 测试插件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm pack<br></code></pre></td></tr></table></figure>

<p>npm pack 之后，会在当前目录下生成一个 xx-btn-1.0.0.tgz 的文件。</p>
<p>打开一个vue项目，将压缩文件放到项目某个目录下，执行命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install 路径\xx-btn-1.0.0.tgz<br></code></pre></td></tr></table></figure>

<p>路径是压缩包所在的<strong>绝对路径</strong>，文件名必须是压缩包的全名</p>
<p>安装好插件后，在项目的入口文件main.js里引入使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> xxBtn <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xx-btn&#x27;</span><br>Vue.use(xxBtn)<br></code></pre></td></tr></table></figure>

<p>之后就可以在项目的任意组件中引用就行了，如果引入成功，则说明打包成功，接下来就是发布到npm上了</p>
<h4 id="8-发布-npm"><a href="#8-发布-npm" class="headerlink" title="8. 发布 npm"></a>8. 发布 npm</h4><p>todo</p>
<div id="paginator"></div></div><div id="post-footer"><hr><a href="/2020/12/08/%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85-npm-%E5%8C%85/">← Prev 离线环境安装 npm 包</a><span style="color: #fe2"> | </span><a href="/2020/12/03/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7-Cypress/">前端自动化测试工具 Cypress Next →</a><hr></div><div id="bottom-btn"><a id="to-index" href="#post-index" title="index">≡</a><a id="to-top" href="#post-title" title="to top">∧</a></div><details id="reward"><summary>打赏</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details><div id="Valine"></div><script>new Valine({
 el: '#Valine'
 , appId: ''
 , appKey: ''
 , placeholder: '此条评论委托企鹅物流发送'
})</script></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a target="_blank" rel="noopener" href="https://github.com/shanliangLS"> Dr.Shining</a></h1><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">14</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">14</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">5</span></div></section></div><div id="aside-block"><h1>INDEX</h1><div id="post-index"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%80%9D%E6%83%B3"><span class="toc-number">1.</span> <span class="toc-text">构造思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">1.1.</span> <span class="toc-text">组件间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E4%B8%9A%E5%8A%A1%E6%97%A0%E5%85%B3"><span class="toc-number">1.2.</span> <span class="toc-text">命名业务无关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E6%97%A0%E5%85%B3"><span class="toc-number">1.3.</span> <span class="toc-text">业务数据无关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E8%81%8C%E8%B4%A3"><span class="toc-number">1.4.</span> <span class="toc-text">组件职责</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.5.</span> <span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3"><span class="toc-number">1.6.</span> <span class="toc-text">上下文无关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">数据扁平化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">1.8.</span> <span class="toc-text">使用自定义事件实现数据的双向绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89-watcher-%E4%BC%98%E5%8C%96-DOM-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.9.</span> <span class="toc-text">使用自定义 watcher 优化 DOM 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%AA%A8%E6%9E%B6"><span class="toc-number">1.10.</span> <span class="toc-text">项目骨架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%E6%89%93%E5%8C%85%EF%BC%8C%E5%8F%91%E5%B8%83%E5%88%B0-npm"><span class="toc-number">2.</span> <span class="toc-text">Vue 组件封装打包，发布到 npm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-webpack-simple-%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.1.</span> <span class="toc-text">使用 webpack-simple 模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA-vue-%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. 新建一个 vue 项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%A8%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%9A%84-src-%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9B%AE%E5%BD%95%EF%BC%88components%EF%BC%89%E7%94%A8%E6%9D%A5%E5%AD%98%E6%94%BE%E6%89%80%E6%9C%89%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. 在新建项目的 src 目录下新建一个目录（components）用来存放所有自定义组件源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%E5%A5%BD%E5%90%8E%E5%9C%A8%E7%BB%84%E4%BB%B6%E7%9B%AE%E5%BD%95%EF%BC%88components%EF%BC%89%E4%B8%8B%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA-index-js-%E6%96%87%E4%BB%B6%EF%BC%8C%E4%B8%BA%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.3.</span> <span class="toc-text">3. 组件封装好后在组件目录（components）下新建一个 index.js 文件，为组件库的入口文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BF%AE%E6%94%B9-package-json-%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.4.</span> <span class="toc-text">4. 修改 package.json 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BF%AE%E6%94%B9-webpack-config-js-%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.5.</span> <span class="toc-text">5. 修改 webpack.config.js 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85%EF%BC%8C%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E4%BB%B6%E5%9C%A8-dist-%E7%9B%AE%E5%BD%95%E4%B8%8B"><span class="toc-number">2.1.6.</span> <span class="toc-text">6. 编译打包，生成的文件在 dist 目录下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%B5%8B%E8%AF%95%E6%8F%92%E4%BB%B6"><span class="toc-number">2.1.7.</span> <span class="toc-text">7. 测试插件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%8F%91%E5%B8%83-npm"><span class="toc-number">2.1.8.</span> <span class="toc-text">8. 发布 npm</span></a></li></ol></li></ol></li></ol></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">github.com/shanliangLS</span></nobr><wbr><wbr><nobr>published with&nbsp;<a target="_blank" rel="noopener" href="http://hexo.io">Hexo&nbsp;</a></nobr><wbr><nobr>Theme&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight&nbsp;</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/arknights.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script></body></html>